# coding: utf-8
#-------------------------------------------------------------------------------
# Test  : ruby 2.3.7p456 (2018-03-28 revision 63024) [universal.x86_64-darwin17]
# Desc  : scraping of exploit information on security focus
# Usage : ruby 01_exploit_check_on_security_focus.rb -f <cveidfile>
#                 => exploit_check_YYYYmmddHHMMSS.log
#-------------------------------------------------------------------------------
ENV['SSL_CERT_FILE'] = File.expand_path('./cert/ca-bundle.crt')
require 'open-uri'
require 'kconv'
require 'nokogiri'
require 'net/https'
require 'optparse'

##
# required    : required args [:a, :b...]
# options     : option args
##
required    = [:f]
options     = {}
date        = Time.new
format_date = date.strftime("%Y%m%d%H%M%S")  # yyyymmdd_HHMMSS

OptionParser.new do |opt|
    begin
        opt.version = 'v1.0'
        opt.banner= "#{File.basename($0)} [options] argument"
        opt.on('-f FILE', 'i.e. CVE-2011-0001 (Newline-delimited)') {|v| options[:f] = v}
        opt.parse!(ARGV)
        
        # Check if any required option is missing
        for field in required
            raise ArgumentError.new("Required option:ï¼ˆ#{field}") if options[field].nil?
        end
    rescue => e
        puts opt.help
        puts
        puts "Error: " + e.message
        exit 1
    end
end

class SearchFromSite
    class << self
        def GetPage uri
            html = open(uri, "r:binary").read
            return Nokogiri::HTML(html.toutf8, nil, 'utf-8')
        end
        
        def PostPage cve
            # Use https
            uri               = URI.parse("https://www.securityfocus.com/bid")
            https             = Net::HTTP.new(uri.host, 443)
            https.use_ssl     = true
            https.verify_mode = OpenSSL::SSL::VERIFY_PEER
            https.ca_file     = './cert/cacert.pem'

            # Make a post query
            response     = nil
            request      = Net::HTTP::Post.new(uri.request_uri, initheader = {'Content-Type' =>'application/x-www-form-urlencoded'})
            request.body = "op=display_list&c=12&vendor=&title=&version=&CVE=" + cve
            
            https.start do |h|
              response = h.request(request)
            end

            return Nokogiri::HTML(response.body.toutf8, nil, 'utf-8')
        end

        def ScrapingURLs (cveid)
            list   = Array.new
            doc    = PostPage cveid
            result = doc.xpath('//div[@style="padding: 4px;"]//a')
            if((result.text).empty?)
                puts "NotFound: " + cveid
            else
                result.each{|a|
                    if (a.text).include?("http://")
                        list.push("https://www.securityfocus.com" + a.attribute('href').value + "/exploit")
                    end
                }
            end

            return list
        end
        
        def ScrapingPages (url_list)
            list = Array.new
            dict = {}
            (url_list.length).times {|i|
                # Get HTML contents as Nokogiri class
                # Ref https://stackoverflow.com/questions/18470672/how-to-get-node-text-without-children
                doc                 = GetPage(url_list[i])
                exploit_title       = doc.xpath('//div[@id="vulnerability"]/span[@class="title"]')
                exploit_description = doc.xpath('//div[@id="vulnerability"]/text()')

                # Parse Nokogiri class into string
                exploit_title       = exploit_title.text
                exploit_description = (exploit_description.text).gsub("\t","").gsub("\n\n","")
                
                # A description which has the message below means there is no exploit code.
                if exploit_description.include?("we are not aware of any")
                    exploit_description = "N/A"
                end
                num  = i.to_s
                dict = {"url" + num => url_list[i], "title" + num => exploit_title, "desc" + num => exploit_description}
                list.push(dict)
            }
            return list
        end
    end
end

begin
    puts "### Start ###"
    if !File.exists?(options[:f])
        raise "Error: File does not exist #{options[:f]}"
    end

    # Get number of CVEID in file
    line_count = 0
    File.open(options[:f],"r"){|cf|

    while cf.gets
      line_count += 1
    end
    }

    filename = "exploit_check_" + format_date + ".log"
    File.open(filename, "w"){|f|
        File.open(options[:f],"r"){|cf|
            cf.each_with_index {|cveid, i|
                cveid   = cveid.chomp
                content = ""
                puts "Processing [" + (i+1).to_s + "/" + line_count.to_s + "]: " + cveid + "\n==="

                urls = SearchFromSite.ScrapingURLs cveid

                if (urls.any?)
                    (SearchFromSite.ScrapingPages(urls)).each_with_index do |dict, i|
                        num = i.to_s
                        content = <<~EOS
                            | CVEID | #{cveid}
                            |-------|--------------------------------------------------
                            | title | #{dict['title' + num]}
                            | url   | #{dict['url' + num]}
                            | desc  | #{dict['desc' + num]}
                        EOS
                    end

                    # Output
                    puts content + "\n"
                    f.puts(content + "\n")    
                end
            }
        }
    }
rescue => e
    puts e.message
end

puts "### End ###"
